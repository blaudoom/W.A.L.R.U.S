package fi.blaudoom.pentestgui.service.utilities;

import fi.blaudoom.pentestgui.GlobalState;
import fi.blaudoom.pentestgui.dao.*;
import fi.blaudoom.pentestgui.model.*;
import fi.blaudoom.pentestgui.model.nmap.*;
import fi.blaudoom.pentestgui.service.settings.SettingsService;
import fi.blaudoom.pentestgui.util.ProcessStreamUtil;
import jakarta.transaction.Transactional;
import org.apache.commons.lang3.StringUtils;
import org.modelmapper.ModelMapper;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;


@Service
public class UtilityServiceImpl implements UtilityService {

    public static final String NMAPNODENAME = "nmaprun";
    public static final String START_ATTR_NAME = "start";
    public static final String HOST = "host";
    public static final String STATUS = "status";
    public static final String ADDRESS = "address";
    public static final String HOSTNAME = "hostname";
    public static final String PORT = "port";
    public static final String SCRIPT = "script";
    public static final String CPE = "cpe";
    public static final String ELEM = "elem";
    public static final String SCANINFO = "scaninfo";
    public static final String TABLE = "table";
    public static final String TCPWRAPPED = "tcpwrapped";
    public static final String UNKNOWN = "[Unknown]";

    private final NmapScanRepository nmapScanRepository;

    private final NmapHostRepository nmapHostRepository;

    private final NmapHostNameRepository nmapHostNameRepository;

    private final NmapServiceRepository nmapServiceRepository;

    private final NmapScriptResultRepository nmapScriptResultRepository;

    private final GlobalState globalState;

    private final ProjectRepository projectRepository;

    private final ModelMapper modelMapper;

    private final TargetRepository targetRepository;

    private final HostnameRepository hostnameRepository;

    private final TargetServiceRepository targetServiceRepository;

    private final ServiceNoteRepository serviceNoteRepository;

    private final NmapScriptElementRepository nmapScriptElementRepository;

    private final ScriptResultRepository scriptResultRepository;

    private final ScriptResultElementRepository scriptElementRepository;

    private final NmapScriptTableRepository nmapScriptTableRepository;

    private final ScriptResultTableRepository scriptResultTableRepository;

    private final ParseQueueObjectRepository parseQueueObjectRepository;

    private final SettingsService settingsService;

    public UtilityServiceImpl(NmapScanRepository nmapScanRepository, NmapHostRepository nmapHostRepository, NmapHostNameRepository nmapHostNameRepository, NmapServiceRepository nmapServiceRepository, NmapScriptResultRepository nmapScriptResultRepository, GlobalState globalState, ProjectRepository projectRepository, ModelMapper modelMapper, TargetRepository targetRepository, HostnameRepository hostNameRepository, TargetServiceRepository targetServiceRepository, ServiceNoteRepository serviceNoteRepository, NmapScriptElementRepository nmapScriptElementRepository, ScriptResultRepository scriptResultRepository, ScriptResultElementRepository scriptElementRepository, NmapScriptTableRepository nmapScriptTableRepository, ScriptResultTableRepository scriptResultTableRepository, ParseQueueObjectRepository parseQueueObjectRepository, SettingsService settingsService) {
        this.nmapScanRepository = nmapScanRepository;
        this.nmapHostRepository = nmapHostRepository;
        this.nmapHostNameRepository = nmapHostNameRepository;
        this.nmapServiceRepository = nmapServiceRepository;
        this.nmapScriptResultRepository = nmapScriptResultRepository;
        this.globalState = globalState;
        this.projectRepository = projectRepository;
        this.modelMapper = modelMapper;
        this.targetRepository = targetRepository;
        this.hostnameRepository = hostNameRepository;
        this.targetServiceRepository = targetServiceRepository;
        this.serviceNoteRepository = serviceNoteRepository;
        this.nmapScriptElementRepository = nmapScriptElementRepository;
        this.scriptResultRepository = scriptResultRepository;
        this.scriptElementRepository = scriptElementRepository;
        this.nmapScriptTableRepository = nmapScriptTableRepository;
        this.scriptResultTableRepository = scriptResultTableRepository;
        this.parseQueueObjectRepository = parseQueueObjectRepository;
        this.settingsService = settingsService;
    }

    @Override
    public String runUtility(Long id) throws InterruptedException, IOException {
        ExecutorService executor = Executors.newFixedThreadPool(10);

        boolean isWindows = System.getProperty("os.name")
                .toLowerCase().startsWith("windows");

        ProcessBuilder builder = new ProcessBuilder();
        if (isWindows) {
            builder.command("cmd.exe", "/c", "dir");
        } else {
            builder.command("nmap", "localhost", "-sV");
        }
        builder.directory(new File(System.getProperty("user.home")));
        Process process = builder.start();
        ProcessStreamUtil streamGobbler =
                new ProcessStreamUtil(process.getInputStream());
        Future<?> future = executor.submit(streamGobbler);

        int exitCode = process.waitFor();
        String output = streamGobbler.getOutput().toString();

        return output;
    }

    @Override
    @Transactional
    public Boolean runNmap(List<String> addresses, List<String> params) throws InterruptedException, IOException, ParserConfigurationException, SAXException {
        Runnable r = () -> {
            try {
                runNmapBackground(addresses, params);
            } catch (Exception e) {
                e.printStackTrace();
            }
        };

        new Thread(r).start();
        return true;
    }

    private String runNmapBackground(List<String> addresses, List<String> params) throws InterruptedException, IOException, ParserConfigurationException, SAXException {
        NmapScan nmapScan = new NmapScan();
        nmapScan.setStatus(ScanStatus.RUNNING);
        nmapScan.setProject(projectRepository.findById(globalState.getCurrentProject()).orElseThrow());
        nmapScan.setProjectRunOrdinal(nmapScanRepository.countByProjectId(nmapScan.getProject().getId()) + 1);
        nmapScan.setStartTime(System.currentTimeMillis() / 1000);
        nmapScan = nmapScanRepository.save(nmapScan);


        ExecutorService executor = Executors.newFixedThreadPool(10);
        List<String> runCommand = new ArrayList<>();

        ProcessBuilder builder = new ProcessBuilder();
        runCommand.add(settingsService.getSetting("nmap").getValue());

        runCommand.addAll(params);

        runCommand.add("-oX");
        runCommand.add("-");
        for (String address : addresses) {
            runCommand.add(address);
        }
        builder.command(runCommand);
        builder.directory(new File(System.getProperty("user.home")));
        Process process = builder.start();
        ProcessStreamUtil streamGobbler =
                new ProcessStreamUtil(process.getInputStream());
        ProcessStreamUtil errorGobbler =
                new ProcessStreamUtil(process.getErrorStream());
        executor.submit(streamGobbler);
        executor.submit(errorGobbler);

        int exitCode = process.waitFor();
        String output = streamGobbler.getOutput().toString();
        String errors = errorGobbler.getOutput().toString();
        if (exitCode != 0) {
            nmapScan.setStatus(ScanStatus.FAILED);
            nmapScan.setErrors(errors);
            nmapScan.setRaw(output);
            nmapScanRepository.save(nmapScan);
            System.out.println(errors);
            return errors;
        }
        nmapScan.setStatus(ScanStatus.PARSING);
        nmapScan.setRaw(output);
        nmapScanRepository.save(nmapScan);
        ParseQueueObject parseQueueObject = new ParseQueueObject();
        parseQueueObject.setRaw(output.trim().replace("\n", ""));
        parseQueueObject.setNmapScan(nmapScan);
        parseQueueObjectRepository.save(parseQueueObject);
        System.out.println(output);
        return output;
    }
    @Scheduled(cron = "0 * * * * ?")
    @Transactional
    public void handleNmapResultsQueue(){
        List<ParseQueueObject> parseQueueObjects = parseQueueObjectRepository.findAllByParsed(false);
        for(ParseQueueObject parseQueueObject : parseQueueObjects){
            try {
                DocumentBuilder xmlBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
                InputSource is = new InputSource(new StringReader(parseQueueObject.getRaw()));

                Document doc = xmlBuilder.parse(is);
                parseNmapResults(doc, parseQueueObject.getNmapScan());
                parseQueueObject.setParsed(true);
                parseQueueObjectRepository.save(parseQueueObject);
            } catch (ParserConfigurationException | IOException | SAXException e) {
                e.printStackTrace();
            }
        }

    }

    private NmapScan parseNmapResults(Document doc, NmapScan nmapScan) {

        nmapScanRepository.save(nmapScan);
        boolean wasInitialized = nmapScan.getProject().getNmapInitialized();
        try {
            parseNmapResultsNode(doc.getDocumentElement(), nmapScan, null, null, null, null);
            for (NmapHost host : nmapScan.getNmapHosts()) {
                nmapHostRepository.save(host);
                Target target = null;
                Optional<Target> optionalTarget = targetRepository.findByProjectIdAndIP(host.getIpAddress(),
                        nmapScan.getProject().getId());
                if (wasInitialized && optionalTarget.isPresent()) {
                    target = optionalTarget.get();

                } else {
                    target = new Target();
                    target.setHostname("pending results");
                    targetRepository.save(target);
                }

                for (NmapHostName hostName : host.getHostnames()) {
                    nmapHostNameRepository.save(hostName);
                    Optional<Hostname> optionalHostname =
                            hostnameRepository.findByTargetAndNameAndType(
                                    target.getId()
                                    , hostName.getHostname()
                                    , hostName.getType());
                    if (optionalHostname.isEmpty()) {
                        Hostname hostname1 = new Hostname();
                        hostname1.setTarget(target);
                        hostname1.setHostname(hostName.getHostname());
                        hostname1.setType(hostName.getType());
                        hostnameRepository.save(hostname1);
                    }

                }
                for (NmapService service : host.getServices()) {
                    nmapServiceRepository.save(service);
                    TargetService targetService = getTargetService(nmapScan, service, target);
                    targetServiceRepository.save(targetService);

                    for (NmapScriptResult result : service.getScriptResults()) {

                        nmapScriptResultRepository.save(result);

                        ScriptResult scriptResult = new ScriptResult();
                        scriptResult.setTargetService(targetService);
                        scriptResult.setContent(result.getOutput());
                        scriptResult.setTitle(result.getName());

                        scriptResultRepository.save(scriptResult);

                        for (NmapScriptTable table : result.getNmapScriptTables()) {
                            nmapScriptTableRepository.save(table);
                            ScriptResultTable resultTable = new ScriptResultTable();
                            resultTable.setScriptResult(scriptResult);
                            resultTable.setElementKey(table.getElementKey());
                            scriptResultTableRepository.save(resultTable);

                            for (NmapScriptTable childTable : table.getChildTables()) {
                                nmapScriptTableRepository.save(childTable);
                                ScriptResultTable childResultTable = new ScriptResultTable();
                                childResultTable.setScriptResultTable(resultTable);
                                childResultTable.setElementKey(childTable.getElementKey());
                                scriptResultTableRepository.save(childResultTable);

                                saveTableElements(childTable, childResultTable);
                            }

                            saveTableElements(table, resultTable);

                        }

                    }
                }

                target.setHostname(host.getHostname());
                target.setIpAddress(host.getIpAddress());
                target.setState(host.getState());
                target.setDescription(host.getDescription());
                target.setInfo(host.getInfo());
                target.setProject(nmapScan.getProject());
                target.setReason(host.getReason());
                targetRepository.save(target);

            }
        } catch (Exception e) {
            e.printStackTrace();
            nmapScan.setStatus(ScanStatus.FAILED);
            nmapScan.setErrors(e.getMessage());
            nmapScanRepository.save(nmapScan);
            projectRepository.save(nmapScan.getProject());
            return nmapScan;
        }

        nmapScan.setStatus(ScanStatus.DONE);
        nmapScan.getProject().setNmapInitialized(true);
        nmapScanRepository.save(nmapScan);
        projectRepository.save(nmapScan.getProject());

        return nmapScan;
    }

    private void saveTableElements(NmapScriptTable table, ScriptResultTable resultTable) {
        for (NmapScriptElement element : table.getNmapScriptElements()) {
            nmapScriptElementRepository.save(element);

            ScriptResultElement resultElement = new ScriptResultElement();
            resultElement.setScriptResultTable(resultTable);
            resultElement.setValue(element.getValue());
            resultElement.setKey(element.getKey());

            scriptElementRepository.save(resultElement);
        }
    }

    private static TargetService getTargetService(NmapScan nmapScan, NmapService service, Target target) {
        TargetService targetService = new TargetService();
        targetService.setTarget(target);
        targetService.setPort(service.getPort());
        targetService.setCpe(service.getCpe());
        targetService.setProduct(service.getProduct());
        targetService.setState(service.getState());
        targetService.setProtocol(service.getProtocol());
        targetService.setName(service.getName());
        targetService.setServicefp(service.getServicefp());
        targetService.setVersion(service.getVersion());
        targetService.setSeenOnScan(nmapScan);
        targetService.setReason(service.getReason());
        targetService.setConf(service.getConf());
        targetService.setMethod(service.getMethod());


        return targetService;
    }

    private static void parseNmapResultsNode(Node node, NmapScan nmapScan, NmapHost host, NmapService service, NmapScriptResult scriptResult, NmapScriptTable scriptTable) {

        //System.out.println("Node: " + node.getNodeName() + " : " + node.getNodeValue());
        //NamedNodeMap nodeMap = node.getAttributes();
        if (node.getNodeName() != null) {
            switch (node.getNodeName()) {
                case NMAPNODENAME:
                    String startTime = node.getAttributes().getNamedItem(START_ATTR_NAME).getNodeValue();
                    nmapScan.setStartTime(Long.valueOf(startTime));
                    String args = node.getAttributes().getNamedItem("args").getNodeValue();
                    nmapScan.setArgs(args);
                    String version = node.getAttributes().getNamedItem("version").getNodeValue();
                    nmapScan.setVersion(version);
                    String xmlOutputVersion = node.getAttributes().getNamedItem("xmloutputversion").getNodeValue();
                    nmapScan.setXmlOutputVersion(xmlOutputVersion);

                    break;
                case SCANINFO:
                    String type = node.getAttributes().getNamedItem("type").getNodeValue();
                    nmapScan.setType(type);
                    String protocol = node.getAttributes().getNamedItem("protocol").getNodeValue();
                    nmapScan.setProtocol(protocol);
                    String numServices = node.getAttributes().getNamedItem("numservices").getNodeValue();
                    nmapScan.setNumServices(Integer.valueOf(numServices));
                    String services = node.getAttributes().getNamedItem("services").getNodeValue();
                    nmapScan.setPorts(services);
                    break;

                case HOST:
                    if (host == null) {
                        host = new NmapHost();
                        host.setNmapScan(nmapScan);
                        nmapScan.getNmapHosts().add(host);
                    }
                    break;

                case STATUS:
                    if (host != null) {
                        host.setState(node.getAttributes().getNamedItem("state").getNodeValue());
                        host.setReason(node.getAttributes().getNamedItem("reason").getNodeValue());
                    }
                    break;

                case ADDRESS:
                    if (host != null) {
                        host.setIpAddress(node.getAttributes().getNamedItem("addr").getNodeValue());
                    }
                    break;
                case CPE:
                    if (service != null) {
                        service.setCpe(node.getNodeValue());
                    }

                case HOSTNAME:
                    if (host != null) {
                        if (node.getAttributes().getNamedItem("name") != null) {
                            if (host.getHostname() == null) {
                                host.setHostname(node.getAttributes().getNamedItem("name").getNodeValue());
                            }
                            if (node.getAttributes().getNamedItem("type") != null) {
                                NmapHostName hostname = new NmapHostName(node.getAttributes().getNamedItem("name").getNodeValue(),
                                        node.getAttributes().getNamedItem("type").getNodeValue());
                                hostname.setNmapHost(host);
                                host.getHostnames().add(hostname);
                            }
                        }
                    }
                    break;

                case PORT:
                    service = new NmapService();
                    service.setNmapHost(host);
                    if (node.getAttributes().getLength() > 0) {
                        if (node.getAttributes() != null && node.getAttributes().getNamedItem("portid") != null)
                            service.setPort(Integer.valueOf(node.getAttributes().getNamedItem("portid")
                                    .getNodeValue()));
                        if (node.getAttributes() != null && node.getAttributes().getNamedItem("protocol") != null)
                            service.setProtocol(node.getAttributes().getNamedItem("protocol")
                                    .getNodeValue());
                        for(Integer i = 0; i < node.getChildNodes().getLength()-1; i++){
                            Node child = node.getChildNodes().item(i);
                            if(child.getNodeName().equals("state") && child.getAttributes().getLength() > 0
                            && child.getAttributes().getNamedItem("state") != null){
                                service.setState(child.getAttributes().getNamedItem("state").getNodeValue());
                                if(child.getAttributes().getNamedItem("reason") != null){
                                    service.setReason(child.getAttributes().getNamedItem("reason").getNodeValue());
                                }
                            }
                            else if(child.getNodeName().equals("service") && child.getAttributes().getLength() > 0
                                    && child.getAttributes().getNamedItem("name") != null){
                                service.setName(child.getAttributes().getNamedItem("name").getNodeValue());
                                if(child.getAttributes().getNamedItem("conf") != null){
                                    service.setConf(child.getAttributes().getNamedItem("conf").getNodeValue());
                                }
                                if(child.getAttributes().getNamedItem("method") != null){
                                    service.setMethod(child.getAttributes().getNamedItem("method").getNodeValue());
                                }
                                if(child.getAttributes().getNamedItem("servicefp") != null){
                                    service.setServicefp(child.getAttributes().getNamedItem("servicefp").getNodeValue());
                                }
                                if(child.getAttributes().getNamedItem("version") != null){
                                    service.setVersion(child.getAttributes().getNamedItem("version").getNodeValue());
                                }
                                if(child.getAttributes().getNamedItem("product") != null){
                                    service.setProduct(child.getAttributes().getNamedItem("product").getNodeValue());
                                }
                            }
                        }
                    }
                    if (StringUtils.isEmpty(service.getName())) {
                        service.setName(UNKNOWN);
                    }

                    host.getServices().add(service);
                    break;


                case SCRIPT:
                    scriptResult = new NmapScriptResult();
                    scriptResult.setNmapService(service);
                    scriptResult.setName(node.getAttributes().getNamedItem("id").getNodeValue());
                    scriptResult.setOutput(node.getAttributes().getNamedItem("output").getNodeValue());
                    service.getScriptResults().add(scriptResult);
                    break;

                case TABLE:
                    if(scriptTable != null){
                        NmapScriptTable childTable = new NmapScriptTable();
                        childTable.setNmapScriptTable(scriptTable);
                        if (node.getAttributes().getNamedItem("key") != null) {
                            scriptTable.setElementKey(node.getAttributes().getNamedItem("key").getNodeValue());
                        }
                        scriptTable.getChildTables().add(childTable);
                        scriptTable = childTable;
                    } else {
                        scriptTable = new NmapScriptTable();
                        scriptTable.setNmapScriptResult(scriptResult);
                        if (node.getAttributes().getNamedItem("key") != null) {
                            scriptTable.setElementKey(node.getAttributes().getNamedItem("key").getNodeValue());
                        }
                        scriptResult.getNmapScriptTables().add(scriptTable);
                    }
                    break;

                case ELEM:
                    if (scriptResult != null && scriptTable != null && node.getAttributes().getNamedItem("key") != null) {
                        NmapScriptElement element = new NmapScriptElement();
                        element.setNmapScriptTable(scriptTable);
                        element.setKey(node.getAttributes().getNamedItem("key").getNodeValue());
                        element.setValue(node.getTextContent());
                        scriptTable.getNmapScriptElements().add(element);
                    }
                    break;


            }
        }

        NodeList nodeList = node.getChildNodes();
        for (int i = 0; i < nodeList.getLength(); i++) {
            Node currentNode = nodeList.item(i);
            if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
                //calls this method for all the children which is Element
                parseNmapResultsNode(currentNode, nmapScan, host, service, scriptResult, scriptTable);
            }
        }
    }

    @Override
    public Integer addUtility(String path, List<String> params) {
        return null;
    }

    @Override
    public List<UtilityDto> listUtilities() {
        return null;
    }

    @Override
    public void importNmapScan(MultipartFile file) throws ParserConfigurationException, IOException, SAXException {

        NmapScan nmapScan = new NmapScan();
        nmapScan.setRaw(new String(file.getBytes()));
        nmapScan.setImported(true);
        nmapScan.setStartTime(System.currentTimeMillis() / 1000);
        nmapScan.setProject(projectRepository.findById(globalState.getCurrentProject()).orElseThrow());
        nmapScan.setProjectRunOrdinal(nmapScanRepository.countByProjectId(nmapScan.getProject().getId()) + 1);
        nmapScan.setStatus(ScanStatus.PARSING);
        nmapScanRepository.save(nmapScan);
        ParseQueueObject parseQueueObject = new ParseQueueObject();
        parseQueueObject.setRaw(new String(file.getBytes()));
        parseQueueObject.setNmapScan(nmapScan);
        parseQueueObjectRepository.save(parseQueueObject);
    }
}
