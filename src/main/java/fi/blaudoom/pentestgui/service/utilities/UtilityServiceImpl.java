package fi.blaudoom.pentestgui.service.utilities;

import fi.blaudoom.pentestgui.GlobalState;
import fi.blaudoom.pentestgui.dao.*;
import fi.blaudoom.pentestgui.model.*;
import fi.blaudoom.pentestgui.model.nmap.*;
import fi.blaudoom.pentestgui.util.ProcessStreamUtil;
import jakarta.transaction.Transactional;
import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;


@Service
public class UtilityServiceImpl implements UtilityService {

    public static final String NMAPNODENAME = "nmaprun";
    public static final String START_ATTR_NAME = "start";
    public static final String HOST = "host";
    public static final String STATUS = "status";
    public static final String ADDRESS = "address";
    public static final String HOSTNAME = "hostname";
    public static final String PORT = "port";
    public static final String SCRIPT = "script";
    public static final String CPE = "cpe";

    private final NmapScanRepository nmapScanRepository;

    private final NmapHostRepository nmapHostRepository;

    private final NmapHostNameRepository nmapHostNameRepository;

    private final NmapServiceRepository nmapServiceRepository;

    private final NmapScriptResultRepository nmapScriptResultRepository;

    private final GlobalState globalState;

    private final ProjectRepository projectRepository;

    private final ModelMapper modelMapper;

    private final TargetRepository targetRepository;

    private final HostnameRepository hostnameRepository;

    private final TargetServiceRepository targetServiceRepository;

    private final ServiceNoteRepository serviceNoteRepository;
    public UtilityServiceImpl(NmapScanRepository nmapScanRepository, NmapHostRepository nmapHostRepository, NmapHostNameRepository nmapHostNameRepository, NmapServiceRepository nmapServiceRepository, NmapScriptResultRepository nmapScriptResultRepository, GlobalState globalState, ProjectRepository projectRepository, ModelMapper modelMapper, TargetRepository targetRepository, HostnameRepository hostNameRepository, TargetServiceRepository targetServiceRepository, ServiceNoteRepository serviceNoteRepository) {
        this.nmapScanRepository = nmapScanRepository;
        this.nmapHostRepository = nmapHostRepository;
        this.nmapHostNameRepository = nmapHostNameRepository;
        this.nmapServiceRepository = nmapServiceRepository;
        this.nmapScriptResultRepository = nmapScriptResultRepository;
        this.globalState = globalState;
        this.projectRepository = projectRepository;
        this.modelMapper = modelMapper;
        this.targetRepository = targetRepository;
        this.hostnameRepository = hostNameRepository;
        this.targetServiceRepository = targetServiceRepository;
        this.serviceNoteRepository = serviceNoteRepository;
    }

    @Override
    public String runUtility(Long id) throws InterruptedException, IOException {
        ExecutorService executor = Executors.newFixedThreadPool(10);

        boolean isWindows = System.getProperty("os.name")
                .toLowerCase().startsWith("windows");

        ProcessBuilder builder = new ProcessBuilder();
        if (isWindows) {
            builder.command("cmd.exe", "/c", "dir");
        } else {
            builder.command("nmap", "localhost", "-sV");
        }
        builder.directory(new File(System.getProperty("user.home")));
        Process process = builder.start();
        ProcessStreamUtil streamGobbler =
                new ProcessStreamUtil(process.getInputStream());
        Future<?> future = executor.submit(streamGobbler);

        int exitCode = process.waitFor();
        String output = streamGobbler.getOutput().toString();

        return output;
    }

    @Override
    @Transactional
    public Boolean runNmap(List<String> addresses, List<String> params) throws InterruptedException, IOException, ParserConfigurationException, SAXException {
        Runnable r = () -> {
            try {
                runNmapBackground(addresses, params);
            } catch (Exception e) {
                e.printStackTrace();
            }
        };

        new Thread(r).start();
        return true;
    }

    private String runNmapBackground(List<String> addresses, List<String> params) throws InterruptedException, IOException, ParserConfigurationException, SAXException {
        NmapScan nmapScan = new NmapScan();
        nmapScan.setStatus(ScanStatus.RUNNING);
        nmapScan.setProject(projectRepository.findById(globalState.getCurrentProject()).orElseThrow());
        nmapScan = nmapScanRepository.save(nmapScan);

        ExecutorService executor = Executors.newFixedThreadPool(10);
        List<String> runCommand = new ArrayList<>();

        boolean isWindows = System.getProperty("os.name")
                .toLowerCase().startsWith("windows");

        ProcessBuilder builder = new ProcessBuilder();
        if (isWindows) {
            runCommand.add("nmap.exe");
            builder.command(runCommand);
        } else {
            runCommand.add("nmap");
            runCommand.add(String.join(" ", addresses));
            runCommand.addAll(params);
            runCommand.add("-oX");
            runCommand.add("-");
            builder.command(runCommand);
        }
        builder.directory(new File(System.getProperty("user.home")));
        Process process = builder.start();
        ProcessStreamUtil streamGobbler =
                new ProcessStreamUtil(process.getInputStream());
        Future<?> future = executor.submit(streamGobbler);

        int exitCode = process.waitFor();
        String output = streamGobbler.getOutput().toString();

        DocumentBuilder xmlBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        InputSource is = new InputSource(new StringReader(output));

        Document doc = xmlBuilder.parse(is);

        parseNmapResults(doc, nmapScan);
        System.out.println(output);
        return output;
    }

    private NmapScan parseNmapResults(Document doc, NmapScan nmapScan) {

        nmapScanRepository.save(nmapScan);
        boolean wasInitialized = nmapScan.getProject().getNmapInitialized();
        try {
            parseNmapResultsNode(doc.getDocumentElement(), nmapScan, null, null);
            for (NmapHost host : nmapScan.getNmapHosts()) {
                nmapHostRepository.save(host);
                if (!wasInitialized) {
                    Target target = new Target();
                    target.setHostname(host.getHostname());
                    target.setIpAddress(host.getIpAddress());
                    target.setState(host.getState());
                    target.setDescription(host.getDescription());
                    target.setInfo(host.getInfo());
                    target.setProject(nmapScan.getProject());
                    targetRepository.save(target);

                    for (NmapHostName hostName : host.getHostnames()) {
                        nmapHostNameRepository.save(hostName);

                        Hostname hostname1 = new Hostname();
                        hostname1.setTarget(target);
                        hostname1.setHostname(hostName.getHostname());
                        hostname1.setType(hostName.getType());
                        hostnameRepository.save(hostname1);

                    }
                    for (NmapService service : host.getServices()) {
                        nmapServiceRepository.save(service);
                        TargetService targetService = new TargetService();
                        targetService.setTarget(target);
                        targetService.setPort(service.getPort());
                        targetService.setCpe(service.getCpe());
                        targetService.setProduct(service.getProduct());
                        targetService.setState(service.getState());
                        targetService.setProtocol(service.getProtocol());
                        targetService.setName(service.getName());
                        targetService.setServicefp(service.getServicefp());
                        targetService.setVersion(service.getVersion());
                        targetServiceRepository.save(targetService);

                        for (NmapScriptResult result : service.getScriptResults()) {
                            nmapScriptResultRepository.save(result);
                            ServiceNote serviceNote = new ServiceNote();
                            serviceNote.setTargetService(targetService);
                            serviceNoteRepository.save(serviceNote);
                        }
                    }
                } else {

                    for (NmapHostName hostName : host.getHostnames()) {
                        nmapHostNameRepository.save(hostName);

                    }
                    for (NmapService service : host.getServices()) {
                        nmapServiceRepository.save(service);

                        for (NmapScriptResult result : service.getScriptResults()) {
                            nmapScriptResultRepository.save(result);
                        }
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            nmapScan.setStatus(ScanStatus.FAILED);
            nmapScanRepository.save(nmapScan);
        }

        nmapScan.setStatus(ScanStatus.DONE);
        nmapScan.getProject().setNmapInitialized(true);
        nmapScanRepository.save(nmapScan);

        return nmapScan;
    }

    private static void parseNmapResultsNode(Node node, NmapScan nmapScan, NmapHost host, NmapService service) {

        //System.out.println("Node: " + node.getNodeName() + " : " + node.getNodeValue());
        //NamedNodeMap nodeMap = node.getAttributes();
        if (node.getNodeName() != null) {
            switch (node.getNodeName()) {
                case NMAPNODENAME:
                    String startTime = node.getAttributes().getNamedItem(START_ATTR_NAME).getNodeValue();
                    nmapScan.setStartTime(Long.valueOf(startTime));
                    break;

                case HOST:
                    if (host == null) {
                        host = new NmapHost();
                        host.setNmapScan(nmapScan);
                        nmapScan.getNmapHosts().add(host);
                    }
                    break;

                case STATUS:
                    if (host != null) {
                        host.setState(node.getAttributes().getNamedItem("state").getNodeValue());
                    }
                    break;

                case ADDRESS:
                    if (host != null) {
                        host.setIpAddress(node.getAttributes().getNamedItem("addr").getNodeValue());
                    }
                    break;
                case CPE:
                    if (service != null) {
                        service.setCpe(node.getNodeValue());
                    }

                case HOSTNAME:
                    if (host != null) {
                        if (node.getAttributes().getNamedItem("name") != null) {
                            if (host.getHostname() == null) {
                                host.setHostname(node.getAttributes().getNamedItem("name").getNodeValue());
                            }
                            if (node.getAttributes().getNamedItem("type") != null) {
                                NmapHostName hostname = new NmapHostName(node.getAttributes().getNamedItem("name").getNodeValue(),
                                        node.getAttributes().getNamedItem("type").getNodeValue());
                                hostname.setNmapHost(host);
                                host.getHostnames().add(hostname);
                            }
                        }
                    }
                    break;

                case PORT:
                    service = new NmapService();
                    service.setNmapHost(host);
                    if (node.getAttributes().getLength() > 0) {
                        if (node.getAttributes().getNamedItem("portid") != null)
                            service.setPort(Integer.valueOf(node.getAttributes().getNamedItem("portid")
                                    .getNodeValue()));
                        if (node.getAttributes().getNamedItem("protocol") != null)
                            service.setProtocol(node.getAttributes().getNamedItem("protocol")
                                    .getNodeValue());

                        if (node.getChildNodes().item(0).getAttributes().getNamedItem("state") != null)
                            service.setState(node.getChildNodes().item(0)
                                    .getAttributes().getNamedItem("state").getNodeValue());

                        if (node.getChildNodes().item(1) != null
                                && node.getChildNodes().item(1).getAttributes().getLength() > 0
                                && node.getChildNodes().item(1).getAttributes().getNamedItem("name") != null)
                            service.setName(node.getChildNodes().item(1)
                                    .getAttributes().getNamedItem("name").getNodeValue());

                        if (node.getChildNodes().item(1) != null
                                && node.getChildNodes().item(1).getAttributes().getLength() > 0
                                && node.getChildNodes().item(1).getAttributes().getNamedItem("servicefp") != null)
                            service.setServicefp(node.getChildNodes().item(1)
                                    .getAttributes().getNamedItem("servicefp").getNodeValue());

                        if (node.getChildNodes().item(1) != null
                                && node.getChildNodes().item(1).getAttributes().getLength() > 0
                                && node.getChildNodes().item(1).getAttributes().getNamedItem("version") != null)
                            service.setVersion(node.getChildNodes().item(1)
                                    .getAttributes().getNamedItem("version").getNodeValue());

                        if (node.getChildNodes().item(1) != null
                                && node.getChildNodes().item(1).getAttributes().getLength() > 0
                                && node.getChildNodes().item(1).getAttributes().getNamedItem("product") != null)
                            service.setProduct(node.getChildNodes().item(1)
                                    .getAttributes().getNamedItem("product").getNodeValue());
                    }

                    host.getServices().add(service);
                    break;


                case SCRIPT:
                    NmapScriptResult scriptResult = new NmapScriptResult();
                    scriptResult.setNmapService(service);
                    scriptResult.setName(node.getAttributes().getNamedItem("id").getNodeValue());
                    scriptResult.setOutput(node.getAttributes().getNamedItem("output").getNodeValue());
                    service.getScriptResults().add(scriptResult);
                    break;


            }
        }

        NodeList nodeList = node.getChildNodes();
        for (int i = 0; i < nodeList.getLength(); i++) {
            Node currentNode = nodeList.item(i);
            if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
                //calls this method for all the children which is Element
                parseNmapResultsNode(currentNode, nmapScan, host, service);
            }
        }
    }

    @Override
    public Integer addUtility(String path, List<String> params) {
        return null;
    }

    @Override
    public List<UtilityDto> listUtilities() {
        return null;
    }
}
